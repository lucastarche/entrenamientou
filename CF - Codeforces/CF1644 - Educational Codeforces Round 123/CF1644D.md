---
contest: "[[CF-1644]]"
tags:
  - Mercor
  - Sorting
---
# D - Cross Coloring

> [!success] [[CF-1644-D.cpp]]
> Hay dos tipos de operaciones: las que afectan a la respuesta (multiplican por k) y las que no.
> Una operación es importante sii es la última en afectar alguna celda, guardo última operación de cada fila/columna y me fijo si afecta a alguien.

## Scratchpad
### Initial Thoughts
- As the operations are fixed, the only difference between reachable states is the colors we choose in each step.
- There are ways of choosing different colors in some operations and reaching the same state, the simplest example is if we perform an operation twice in a row, as the second operation "overwrites" the first one.
- This is not the only way to overwrite operations though, for example in a $2\times2$ grid, we can overwrite an operation $(1, 1)$ by performing operations in $(2, 1)$ and $(1, 2)$ with the desired color.
- With this, I noticed that the final color of a cell only depends on the color of the last operation which affected, we want some way of finding out which operation it was.

### Step-by-Step Solution
- As operations only affect their own row and column, for some cell $(x, y)$, the last operation which affected it must have affected either row $x$ or column $y$.
- We can keep track of the last operation which affected each row/column, and then compute the appropriate value for this cell.
- However, the number of cells can be really big ($\approx 4 \cdot 10^{10}$), there is no way to consider each cell of the grid independently.
- Notice that cells which were affected by the same last operation will have the same color at the end of the process, we only care about whether or not _some_ cell will have the color of operation $i$ at the end of the process.
- This also means the answer will be $k^x \pmod{998244353}$, where $x$ is the number of operations which determine the color of some cell at the end of the process.
- Let's consider two auxiliary arrays: $r_1, \dots, r_n$ and $c_1, \dots, c_m$, the last operation which affected each row and column, respectively.
- An operation $i$ is not overwritten if and only if there is some cell $(x, y)$ such that $\max(r_x, c_y) = i$, as $\max(r_x, c_y)$ is the last operation which affected this cell.
- If we want some cell to have the value of $r_x$, then we should choose $c_y$ as small as possible, as we want to force $\max(r_x, c_y) = r_x$, which means $r_x \geq c_y$ should hold.
- We can apply a similar reasoning when we want $\max(r_x, c_y) = c_y$, we should take the smallest possible value of $r_x$.
- For rows/columns which were never affected by an operation, we can set a sentinel value of -1, as the color for each cell will always be determined by the other line (column or row, respectively).
- This idea works, but gets a Time Limit Exceeded verdict on test 6: this is because the only guarantee is that $\sum q \leq 2 \cdot 10^5$, the values of $\sum n$ and $\sum m$ could grow very large.
- The problem right now is we are assigning and iterating the values of $r_x$ and $c_y$, but if $q \ll n$, most of these will simply be "-1".
- To avoid creating elements we don't look at, we can simply use a dictionary instead, where we only store the last operation for rows/columns which were affected by some operation.
- We should now be careful when computing the minimum value of $r$ and $c$, as there might be some "-1" missing we don't see, as it is not stored in the dictionary.
- We can handle this by comparing the size of the dictionary to the number of rows / columns, if they don't match there must be a -1.

## Final Solution
- Create two dictionaries, one for the rows and one for columns, which we call $r$ and $c$, respectively.
- Process operations in order, for each operation $x_i, y_i$, we set values $r_{x_i}$ and $c_{x_i}$ equal to $i$.
- After this, compute the minimum values of $r$ and $c$: if $|r| = n$, this is the minimum value, otherwise it is $-1$, we apply the same reasoning for $c$, and note them as $m_r, m_c$ respectively.
- Create a boolean array with $q$ entries, stating whether or not an operation influences the final result.
- For each value $x$ in $r$, set index $\max(x, m_c)$ in the boolean array.
- Similarly, for each value $x$ in $c$, set $\max(x, m_r)$ in the boolean array.
- The answer is $k^y$, where $y$ is the number of true elements in the boolean array.