---
contest: "[[CF-1648]]"
tags:
  - Mercor
  - Sorting
  - Number-Theory
---
# B - Integral Array

> [!success] [[CF-1648-B.cpp]]
> Fijo el valor de $y$ y $k$ de manera que $\lfloor \frac{x}{y} \rfloor = k$, $x$ tiene que estar en el intervalo $[ky, (k+1)y)$ para poder formar este valor de $k$.
> Si $k$ no está en $a$, hago binaria para fijarme, corre rápido porque si todos los y's son distintos, está acotado por harmónica

> [!success] [[CF-1648-B-2.cpp]]
> Similar al anterior, pero me puedo ahorrar la binaria si precomputo mínimo elemento más grande que $x$ para todo $x$, me fijo a la derecha de $ky$.
> Raro que resulta ser casi tan rápido como el código anterior, difieren en $\approx 100\text{ms}$, cuando el código tarda $\approx 1200\text{ms}$. 

## Scratchpad
### Initial Thoughts
- Repeat occurrences of an element do not matter, as we could choose $x = y$ for the integral condition already.
- This, combined with the fact that $C \leq 10^6$, means we can simply create a binary array with $c$ elements, stating whether or not some element $x$ is present.
- For a fixed value of $x$, we know that the different values $\lfloor \frac{x}{y} \rfloor$ can take is bounded by $O(\sqrt{x})$: if $\lfloor \frac{x}{y} \rfloor \leq \sqrt{x}$ there are at most $\sqrt{x}$ different values, otherwise $\lfloor \frac{x}{y} \rfloor > \sqrt{x}$,  which means $\frac{x}{y} > \sqrt{x}$, and $\sqrt{x} > y$, so there are at most $\sqrt{x}$ values of $y$ for which $\lfloor \frac{x}{y} \rfloor > \sqrt{x}$.
- However, $O(C \sqrt{C})$ seems too tight for the given constraints (as $C \cdot \sqrt{C} \approx 10^9$), fixing $x$ and iterating over every value $\lfloor \frac{x}{y} \rfloor$ can take does not seem to be the intended solution.
- It's clear that $1$ should always belong to the array, as $\lfloor \frac{x}{x} \rfloor = 1$ for every $x$.
- Let's try to change the approach: perhaps we can fix the value of $y$ instead, and look at every value $\lfloor \frac{x}{y} \rfloor$ can take instead.
- There are only $O(\frac{C}{y})$ values it can take, as the largest possible value would be $\lfloor \frac{C}{y} \rfloor$, and we can subtract $y$ iteratively to get every other floor value until reaching $1$.
- This is more promising, as we can get a Harmonic Sum bound: as $\sum_{i=1}^n \frac{1}{i} \approx \log n$, then $\sum_{y=1}^{C} \frac{C}{y} = C \cdot \sum_{y=1}^C \frac{1}{y} = O(C \log C)$.

### Step-by-Step Solution
- Let's fix some value $y$ in the array, we want to know which values of $\lfloor \frac{x}{y} \rfloor$ we should check for.
- If we want $\lfloor \frac{x}{y} \rfloor = k$ then $x$ should belong to the interval $[k \cdot y, (k + 1) \cdot y)$, this floor value is only reached if there is _some_ element in this interval.
- We can check whether or not an element is present in $O(\log n)$ time: we keep a sorted list of elements, and run a binary search for the smallest element greater or equal than $k \cdot y$.
- This would mean having an $O(N \log C \log N)$ solution, as for each value in the array, we iterate over each possible floor value, and then run a binary search.
- It turns out to be fast enough, as the operations we perform in each step are quite cheap, and we have two seconds of time limit.

## Final Solution
- Start by sorting and filtering repeat elements of $a$, and create a binary array stating whether or not an element is present in $a$.
- Iterate through every element $y$ inside of $a$. 
- For each $k$ such that $k \cdot y \leq c$ but $k$ is not present in the array (which we can check using the binary array from before), we want to ensure there is no $x \in a$ such that $k \cdot y \leq x < (k + 1) \cdot y$.
- For this, we can run a binary search on $a$ over the smallest value greater or equal than $k \cdot y$, and compare it against $(k + 1) \cdot y$.
- If there is such element $x$, the answer is "No", otherwise the answer is "Yes".