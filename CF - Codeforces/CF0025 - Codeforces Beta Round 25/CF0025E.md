---
contest: "[[CF-0025]]"
tags:
  - Mercor
  - Strings
---
# E - Test

> [!success] [[CF-0025-E.cpp]]
> Es parecido a otros problemas de strings, donde buscamos un camino hamiltoniano que tenga todos los strings.
> Era cómodo pensarlo con Prefix Automaton, pero también se puede computar "cantidad de caracteres para poner $s_j$ después de $s_i$" y buscar el camino, ahí hay que tener cuidado que ningún string esté contenido adentro de otro

## Scratchpad
### Initial Thoughts

- We want to find the shortest string $s$ which contains $s_1, s_2$ and $s_3$.
- If no prefix of $s$ were equal to some $s_i$, we could remove the first character of $s$, and get a shorter string.
- We can apply the same argument for suffixes of $s$, so $s$ must be a prefix equal to some $s_i$, a suffix equal to some $s_j$, and perhaps some characters in the middle to get a match of the third string.
- We can assume no $s_i$ is a substring of some other string $s_j$, otherwise we could remove the shorter of the two, and solve the problem for less strings.

### Step-by-Step Solution

- Let's assume that $s_1$ is a prefix of $s$, then we match $s_2$, and finally $s_3$ matches a suffix of $s$.
- If we can compute the shortest string $s$ with this property, we can then solve the original problem by running this procedure six times, once for each permutation of indices $\set{1, 2, 3}$.
- After adding $s_1$, we will have matched some (possibly empty) prefix of $s_2$, we want to add the remaining characters to complete the corresponding match.
- There is a way of maintaining the length of the longest prefix matched at any point in time: we can build a so-called "Prefix Automaton" of $s_2$, and update the length after we add every character of $s_1$.
- Once we finish adding every character of $s_1$, we will have to add the remaining characters of $s_2$, and have a similar situation for $s_3$.
- For this, we could also compute a prefix automaton of $s_3$, and keep track of the corresponding prefix as we add the characters from both $s_1$ and $s_2$.
- Let's describe how to compute this prefix automaton, which given a string $s$, gives us a finite automaton (we can think about it as a graph with labelled vertices) with $|s| + 1$ nodes $0, \dots, |s|$, the possible lengths a prefix can match.
- If we have matched some prefix of length $x$ and add some character $c$, we can either have matched an additional character, moving to state $x + 1$, or we might need to shrink the prefix and try to transition again.
- For this, we can use the prefix function $\pi$, where $\pi(x)$ is the length of the largest "proper border" of $s[1..x]$, that is, a substring which is both a prefix and suffix of $s[1..x]$, but is not the entire string.
- This gives us a way to recursively define the transition function of our automaton: if $s_{x + 1} = c$, $f(x, c) = x + 1$.
- Otherwise, we need to shrink the prefix as little as possible and try to match the character again, which means $f(x, c) = f(\pi(x), c)$.
- As $\pi(0) = 0$, we don't yet know how to compute $f(0, c)$ when $s_1 \neq c$.
- We define $f(0, c) = 0$ in these cases, as we have an empty character, and the new character does not match the appropriate character.
- The prefix function $\pi$ can be computed in linear time by using the Knuth-Morris-Pratt algorithm, which means we can build the automaton in $O(\Sigma n)$ time, where $\Sigma = 26$ is the size of the alphabet.
- We can now modify our approach to handle the case when a string is contained is inside another: if at some point, the length of the prefix of $s_2$ or $s_3$ reaches the entire length, we have found a match in the answer string, and avoid adding the corresponding suffix to the answer.

## Final Solution

- Iterate through every permutation of the input strings, and compute the answer if we want to first match $s_1$, then match $s_2$, and finally match $s_3$.
- For this, compute the Prefix Automaton of $s_2$ and $s_3$ in $O(\Sigma n)$ time, where $\Sigma = 26$ is the number of characters in the alphabet.
- The Prefix Automaton of a string $s$ is a function $f(x, c)$ which tells us, if we have matched a prefix of length $x$ of $s$, the length of the longest suffix of $s$ we will have matched after appending character $c$.
- For this, we can compute the prefix function $\pi(x)$ of $s$ using the KMP algorithm, where $\pi(x)$ is the length of the longest prefix of $s[1..x]$ which is also a suffix, without being the entire string, where we define $\pi(0) = 0$.
- To compute the Prefix Automaton, we can do so in increasing order of $x$: $f(x, c) = x + 1$ if $s_{x+1} = c$, or $f(x, c) = f(\pi(x), c)$ otherwise.
- If $x = \pi(x) = 0$ and $s_1 \neq c$, we simply say that $f(0, c) = 0$.
- If $x = |s|$, then $f(x, c) = f(\pi(x), c)$.
- We can now compute the answer as follows: keep track of the length of the prefix matched for both $s_2$ and $s_3$, which we denote as $x_2$ and $x_3$, as well as a flag for each of them, stating if we matched $s_2$ or $s_3$ already.
- A match occurs whenever the length of the matched prefix equals the length of the entire string, that is, if $x_2 = |s_2|$ or $x_3 = |s_3|$ happen, respectively.
- We start by adding every character of $s_1$ to the answer.
- Then, if we have yet to match $s_2$, we add the missing characters in $s_2$ to the answer: we have matched $x_2$ characters already, so we add those in $s_2[x_2+1..|s_2|]$.
- After this, we do the same with $s_3$ as well, the answer will be the number of characters.